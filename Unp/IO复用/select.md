# select函数

该函数允许进程指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒它

```c
#include <sys/select.h>
#include <sys/time.h>
int select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout); //返回：若有就绪描述符则为其数目，若超时则0，出错为-1
```

> __timeout参数__告知内核等待所指定描述符中的任何一个就绪可花多长时间
>
> 这个参数有三个可能
>
> 1. 永远等待下去：仅在有一个描述符准备好I/O时才返回。设置为空指针
> 2. 等待一段固定时间：在有一个描述符准备好I/O时返回，但是不超过由该参数所指向的timeval结构中所指定的秒数和微秒数
> 3. 根本不等待：检查描述符后立即返回，称为**轮询**。设置该参数必须指向一个timeval结构，而且值必须是0

```c
struct timeval{
    long tv_sec;    //秒
    long tv_usec;   //微秒
}
```

> __中间三个参数__指定我们要让内核测试读、写和异常条件的描述符
>
> 支持的异常条件
>
> 1. 某个套接字的带外数据的到达
> 2. 某个已置为分组模式的伪终端存在可从其主端读取的控制状态信息

select使用描述符集，通常是一个整数数组

````c
void FD_ZERO(fd_set *fdset);
void FD_SET(int fd, fd_set *fdset);
void FD_CLR(int fd, fd_set *fdset);
int FD_ISSET(int fd, fd_set *fdset);
````

> 头文件<sys/select.h>定义了FD_SETSIZE常值是数据类型fd_set中描述符总数。
>
> 注：描述符是用**0开始**的

## 描述符就绪条件

------

满足四个条件中的任何一个时，套接字准备好**读**

> - 该套接字接收缓冲区中的数据字节数__大于等于__套接字接收缓冲区低水平标记的当前大小，这样的套接字执行读操作不会阻塞并返回一个大于0的值
> - 该连接的读半部关闭（也就是接收了FIN的TCP连接），这样的套接字读操作将不阻塞并返回0（也就是EOF）
> - 该套接字是一个监听套接字且已完成的连接数不为0
> - 其上有一个套接字错误待处理，这样的套接字读操作将不阻塞并返回-1（也就是返回错误），同时将errno设置成确切的错误条件

满足四个条件中的任何一个，套接字准备好**写**

> - 该套接字发送缓冲区中的可用空间字节数__大于等于__套接字发送缓冲区低水平标记的当前大小，并且该套接字已连接或者该套接字不需要连接（如UDP套接字）
> - 该连接的写半部关闭，执行写操作产生SIGPIPE信号
> - 使用非阻塞式connect的套接字已建立连接，或者connect已经以失败告终
> - 其上有一个套接字错误待处理，这样的套接字写操作将不阻塞并返回-1，同时把errno设置成确切的错误条件
