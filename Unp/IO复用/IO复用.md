# I/O复用

> 进程一种预先告知内核的能力，使得内核一旦发现进程指定的一个或多个I/O条件就绪，它就通知进程

## I/O复用典型使用在下列网络应用场合

> - 当客户处理多个描述符时（通常是交互式输入和网络套接字），必须使用I/O复用
> - 一个客户同时处理多个套接字是可能的，不过比较少见
> - 如果一个TCP服务器既要处理监听套接字，又要处理已连接套接字，一般就要使用I/O复用
> - 如果一个服务器既要处理TCP，又要处理UDP，一般就要使用I/O复用
> - 如果一个服务器要处理多个服务或者多个协议，一般就要使用I/O复用

### I/O模型

--------

Unix下可用的5种I/O模型：阻塞式I/O，非阻塞式I/O，I/O复用（select和poll），信号驱动式I/O，异步I/O（POSIX的aio_系列函数）

一个输入操作通常包括两个不同的阶段：

1. 等待数据准备好
2. 从内核向进程赋值数据

#### 阻塞式I/O模型

> 最流行的I/O模型是阻塞式I/O模型，默认情形下，所有的套接字都是阻塞的。

#### 非阻塞式I/O模型

> 进程把一个套接字设置成非阻塞是在通知内核：当所请求的I/O操作非得把本进程投入睡眠才能完成，不要把本进程投入睡眠，而是返回一个错误

#### I/O复用模型

> 有了I/O复用，我们就可以调用select和poll，阻塞在这两个系统调用中的某一个之上，而不是阻塞在真正的I/O系统调用上。使用select的有时在于我们可以等待多个描述符就绪

#### 信号驱动式I/O模型

用信号让内核在描述符就绪时发送SIGIO信号通知我们。

> 优势是在等待数据报到达期间进程不被阻塞，主循环可以继续执行，只要等待来自信号处理函数的通知：既可以是数据已准备好被处理，也可以是数据报已准备好被读取

#### 异步I/O模型

异步I/O由POSIX规范定于

> 工作机制：告知内核启动某个操作，并让内核在整个操作（包括将数据从内核复制到我们自己的缓冲区）完成后通知我们
>
> 与信号驱动式模型的**主要区别**：信号驱动式I/O是由内核通知我们何时可以启动一个I/O操作，而异步I/O模型是由内核通知我们I/O操作何时完成
>
> POSIX异步I/O函数以**aio_**或**lio_**开头，我们调用aio_read函数，给内核传递描述符、缓冲区指针、缓冲区大小（与read相同的三个参数）和文件偏移（与lseek类似），并告诉内核当整个操作完成是如何通知我们

#### 各种I/O模型的比较

> 前4种模型的主要区别在于第一阶段，因为它们的第二阶段是一样的：在数据从内核赋值到调用者的缓冲区期间，进程阻塞与recvfrom调用，相反，异步I/O模型在这两个阶段都要处理，从而不同与其他4种模型

#### 同步I/O和异步I/O对比

> - 同步I/O操作导致请求进程阻塞，知道I/O操作完成
> - 异步I/O操作不导致请求进程阻塞
